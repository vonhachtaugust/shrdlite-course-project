///<reference path="World.ts"/>
///<reference path="Interpreter.ts"/>
///<reference path="Graph.ts"/>

/** 
* Planner module
*
* The goal of the Planner module is to take the interpetation(s)
* produced by the Interpreter module and to plan a sequence of actions
* for the robot to put the world into a state compatible with the
* user's command, i.e. to achieve what the user wanted.
*
* The planner should use your A* search implementation to find a plan.
*/
module Planner {

    //////////////////////////////////////////////////////////////////////
    // exported functions, classes and interfaces/types

    /**
     * Top-level driver for the Planner. Calls `planInterpretation` for each given interpretation generated by the Interpreter. 
     * @param interpretations List of possible interpretations.
     * @param currentState The current state of the world.
     * @returns Augments Interpreter.InterpretationResult with a plan represented by a list of strings.
     */
    export function plan(interpretations: Interpreter.InterpretationResult[], currentState: WorldState): PlannerResult[] {
        var errors: Error[] = [];
        var plans: PlannerResult[] = [];
        interpretations.forEach((interpretation) => {
            try {
                var result: PlannerResult = <PlannerResult>interpretation;
                result.plan = planInterpretation(result.interpretation, currentState);
                if (result.plan.length == 0) {
                    result.plan.push("That is already true!");
                }
                plans.push(result);
            } catch (err) {
                errors.push(err);
            }
        });
        if (plans.length) {
            return plans;
        } else {
            // only throw the first error found
            throw errors[0];
        }
    }

    export interface PlannerResult extends Interpreter.InterpretationResult {
        plan: string[];
    }

    export function stringify(result: PlannerResult): string {
        return result.plan.join(", ");
    }

    //////////////////////////////////////////////////////////////////////
    // private functions

    /**
     * The core planner function.
     * 
     * @param interpretation The logical interpretation of the user's desired goal. The plan needs to be such that by executing it, the world is put into a state that satisfies this goal.
     * @param state The current world state.
     * @returns Basically, a plan is a
     * stack of strings, which are either system utterances that
     * explain what the robot is doing (e.g. "Moving left") or actual
     * actions for the robot to perform, encoded as "l", "r", "p", or
     * "d". The code shows how to build a plan. Each step of the plan can
     * be added using the `push` method.
     */
    function planInterpretation(interpretation: Interpreter.DNFFormula, state: WorldState): string[] {

        let stateGraph: StateGraph = new StateGraph();
        var isGoal = (n: any) => goal(interpretation, n);
        var heuristic = (n: any) => heuristicFunction(n, interpretation);
        
        let path = aStarSearch(
            stateGraph,
            state,
            isGoal,
            heuristic,
            10
        );
        
        if (typeof path == "undefined") {
            throw "Timeout. Maybe no path exists?";
        }
        
        let stateSequence = path.path;
        stateSequence.unshift(state);
        
        let plan = pathToPlan(stateSequence);
        
        plan = insertActionDescriptionTexts(plan, stateSequence);
        
        return plan;
    }
    
    function pathToPlan(path : WorldState[]) : string[] {
        
        // return value
        let result : string[] = [];
        
        for (let i = 1; i < path.length; i++) {
            let currentState = path[i-1];
            let nextState = path[i];
            
            if (currentState.arm < nextState.arm) {
                // moved arm to the right
                result.push("r");
            } else if (currentState.arm > nextState.arm) {
                // moved arm to the left
                result.push("l");
            } else {
                // dropped or picked up
                if (currentState.holding != null && nextState.holding == null) {
                    // dropped
                    result.push("d");
                } else if (currentState.holding == null && nextState.holding != null) {
                    // picked up
                    result.push("p");
                } else {
                    console.error("pathToPlan() got invalid path: " + path);
                }
            }
        }
        return result;
    }
    
    /**
     * insert descritive updates at appropriate places in the plan
     */
    function insertActionDescriptionTexts(plan : string[], stateSequence : WorldState[]) : string[] {
        
        // next position in plan to insert descriptive text
        let printPos = 0;
        let entity = null;
        
        // find out where the last move places it's object
        let lastRelativeEntityTag = null;
        let lastRelativeEntity;
        let relativeEntityRelation = "on";
        let lastState = stateSequence[stateSequence.length - 1];
        if (lastState.holding == null) {
            let relativeStack = lastState.stacks[lastState.arm];
            if (relativeStack.length == 1) {
                lastRelativeEntityTag = "floor";
            } else {
                lastRelativeEntityTag = relativeStack[relativeStack.length - 2];
                lastRelativeEntity = lastState.objects[lastRelativeEntityTag];
                if (lastRelativeEntity.form == "box") {
                    relativeEntityRelation = "in";
                }
            }
        } else {
            // the arm is holding something in the last state, the command was 'take'
        }
        
        let i = 0;
        let stateIndex = 0;
        let numInsertedTexts = 0;
        while (stateIndex < stateSequence.length) {
            
            if (i == plan.length) break;
            
            if (plan[i] == "p") {
                // identified current entity, print at last known position
                
                // state before this action
                let state = stateSequence[stateIndex];
                
                // what was picked up
                let entityStack = state.stacks[state.arm];
                let entityTag = entityStack[entityStack.length - 1];
                let entity = state.objects[entityTag];
                
                let entityString = stringifyEntity(entity, state);
                
                let text = "";
                
                if (plan.indexOf("d", i+1) == -1) {
                    // target will not be dropped
                    text += "I take " + entityString;
                } else if (plan.indexOf("p", i+1) == -1) {
                    // target will be dropped, but nothing else will be picked up
                    let relativeText;
                    if (lastRelativeEntityTag == "floor") {
                        relativeText = "the floor"
                    } else {
                        relativeText = stringifyEntity(lastRelativeEntity, state);
                    }
                    text += "I put "
                            + entityString + " "
                            + relativeEntityRelation + " "
                            + relativeText;
                } else {
                    text += "I move " + entityString;
                }
                
                plan.splice(printPos, 0, text);
                numInsertedTexts++;
                i++;
            }
            
            // find next position at which to print
            if (plan[i] == "d") {
                printPos = i + 1;
            }
            
            i++;
            stateIndex++;
        }
        
        // add 'first', 'then'
        if (numInsertedTexts > 1) {
            for (let i = plan.length - 1; i >= 0; i--) {
                if (!(plan[i] == "r" || plan[i] == "l" || plan[i] == "d" || plan[i] == "p")) {
                    // plan[i] is an action description
                    plan[i] = "Finally, " + plan[i];
                    break;
                }
            }
            for (let i = 0; i < plan.length; i++) {
                if (!(plan[i] == "r" || plan[i] == "l" || plan[i] == "d" || plan[i] == "p")) {
                    // plan[i] is an action description
                    if (plan[i].indexOf("Finally, ") > -1) {
                        break;
                    } else if (i == 0) {
                        plan[i] = "First, " + plan[i];
                    } else {
                        let nextText;
                        if (Math.random() < 0.5) {
                            nextText = "Then, ";
                        } else {
                            nextText = "Next, ";
                        }
                        plan[i] = nextText + plan[i];
                    }
                }
            }
        }
        
        return plan;
    }
    
    /**
     * generate a descriptive text which uniquely identifies 'entity'
     */
    export function stringifyEntity(entity, state) : string {
        
        let res = "the "
        
        let uniqueCombs = findUniqueIdCombs(entity, state);
        let uniqueComb = uniqueCombs[uniqueCombs.length - 1];
        
        let propsPrintOrder = props.reverse();
        
        let encounteredForm = false;
        for (let i = 0; i < propsPrintOrder.length; i++) {
            let prop = propsPrintOrder[i];
            
            if (uniqueComb.indexOf(prop) == -1) continue;
            
            res += entity[prop] + " ";
            
            if (!encounteredForm && prop == "form") {
                encounteredForm = true;
            }
        }
        
        props.reverse(); // reverse props back
        
        if (!encounteredForm) {
            res += "object";
        }
        
        return res;
    }
    
    let props = ["form", "color", "size"]; // defines the priority in which to remove properties
    /**
     * get the list of all permutations of object properties that uniquely defines the same object
     * as @param entity in @param state. Last combination in the list will be the shortest.
     */
    function findUniqueIdCombs(entity, state : WorldState) {
        //
        // assertion: 'entity' is unique in 'state'
        //
        
        // generate the list of possible entities 
        let possibleTags = Interpreter.getPossibleEntitieTags(entity, state);
        if (possibleTags.length > 1) {
            return [];
        }
        
        let uniqueCombs = [];
        
        // compute the current property combination
        let comb = [];
        for (let prop in entity) {
            if (entity[prop] != null) {
                comb.push(prop);
            }
        }
        uniqueCombs.push(comb);
        
        // remove properties one by one
        for (let i = 0; i < props.length; i++) {
            if (comb.indexOf(props[i]) == -1) continue;
            
            let prop = props[i];
        
            // clone entity object
            let testEntity = cloneObject(entity);
            
            // try removing this property from testEntity
            testEntity[prop] = null;
            
            let recCombs = findUniqueIdCombs(testEntity, state);
            uniqueCombs = uniqueCombs.concat(recCombs);
        }
        
        return uniqueCombs;
    }

    /**
     * function used by isGoal to check the current world state with the interpretation
     */
     function goal(interpretation: Interpreter.DNFFormula, state: WorldState): boolean {
        // for each found interpretation
        for (let i = 0; i < interpretation.length; i++) {
            // for each disjunctive goal
            let thisDisjRes = true;
            for (let j = 0; j < interpretation[i].length; j++) {
                // fufill a conjunctive goal
                thisDisjRes = thisDisjRes && Planner.conjunctive(interpretation[i][j], state);
            }
            if (thisDisjRes) {
                return true;
            }
        }
        return false;
    }

    export function conjunctive(interpretation: any, state : WorldState): boolean {
        // function assumes  previous required conditions between number of arguments given a relation etc. are handled. See Interpreter.ts
        let relation = interpretation.relation;
        let args = interpretation.args;

        if (relation == "holding") {
            return (state.holding == args[0]);
        }
        else if ((relation == "inside") || (relation == "ontop")) {
            if (Interpreter.isInSameStack(args[0], args[1], state)) {
                return (Interpreter.stackIndexOf(args[0], state) - 1 == Interpreter.stackIndexOf(args[1], state));
            }
            return false;
        }
        else if (relation ==  "above") {
            if (Interpreter.isInSameStack(args[0], args[1], state)) {
                return (Interpreter.stackIndexOf(args[0], state) > Interpreter.stackIndexOf(args[1], state));       
            }
            return false;
        }
        else if (relation == "under") {
            if (Interpreter.isInSameStack(args[0], args[1], state)) {
                return (Interpreter.stackIndexOf(args[0], state) < Interpreter.stackIndexOf(args[1], state));
            }
            return false;
        }        else if (relation == "beside") {
            return (Interpreter.stackIndex(args[0], state) + 1 == Interpreter.stackIndex(args[1], state))
            || (Interpreter.stackIndex(args[0], state) - 1 == Interpreter.stackIndex(args[1], state));
        }
        else if (relation == "leftof") {
            return (Interpreter.stackIndex(args[0], state)  < Interpreter.stackIndex(args[1], state));
        }
        else if (relation == "rightof") {
            return (Interpreter.stackIndex(args[0], state)  > Interpreter.stackIndex(args[1], state));
        }
        // the relation doesn't exist.
        return false;
    }


    /**
     * function for calculating the heuristic for state 's'
     */
    export function heuristicFunction(state: WorldState, interpretation : Interpreter.DNFFormula) : number {
        
        let isGoal = goal(interpretation, state);
        if (isGoal) {
            return 0;
        }

        let disjGoals : Interpreter.Literal[][] = interpretation;
        
        // result heuristic will be the minimum of the heuristics for the disjunctions
        let minHeuristic = Infinity;
        
        // assumes that interpretation is a list of disjunctive goals
        for (let i = 0; i < disjGoals.length; i++) {
            
            // list of conjunctions for this disjunctive goal
            let thisDisjunction : Interpreter.Literal[] = disjGoals[i];
            
            // heuristic for this disjunction will be the sum of the heuristics for the conjunctions
            let thisHeuristic = 0;
            
            for (let j = 0; j < thisDisjunction.length; j++) {
                let thisConjunction : Interpreter.Literal = thisDisjunction[j];
                thisHeuristic += estimatedPathLength(state,thisConjunction);
            }
            
            if (thisHeuristic < minHeuristic) {
                minHeuristic = thisHeuristic;
            }
        }
        return minHeuristic;
    }
    
    function estimatedPathLength(state : WorldState, condition : Interpreter.Literal) {
        
        // return value
        let result : number = 0;
        let polarity = condition.polarity; // assumed to be true for now
        let rel = condition.relation;
        let args = condition.args;
        let t = 0;
        
        if (rel == undefined || args == undefined) {
            console.error("Arguments = " + args + " | " + "relation = " + rel);
        }

        // 'inside' has same estimated path length as 'ontop'
        if (rel == "inside") {
            rel = "ontop";
        }

        if (rel == "holding") 
        {
            if (args.length == 1) {

                let targetTag = args[0];
                
                if (targetTag == state.holding) {
                    // already holding desired object
                    return 0;
                } else if (state.holding != null) {
                    result++;
                }
                
                let targetStackIndex = Interpreter.stackIndex(targetTag, state);
                let targetStackIndexOf = Interpreter.stackIndexOf(targetTag, state);
                
                if (typeof targetStackIndex == "undefined" || typeof targetStackIndexOf == "undefined") {
                    // target is the floor, or non-existing entity
                    return Infinity;
                } 
                
                // move arm to target stack
                result += Math.abs(state.arm - targetStackIndex);
                
                // number of obstacles in the way of picking up 'target'
                let numObstacles = state.stacks[targetStackIndex].length - (targetStackIndexOf + 1);
                
                // for each obstacle, pick up (+1), move away (+1), drop (+1) and move back (+1), (+4) in total
                result += 4 * numObstacles;
                
                // pick up 'target'
                result++;
            } else {
                console.error("estimatedPathLengt h() got condition 'holding' with args: " + args)
            }
        }
        else if (rel == "above" || rel == "under") {
            if (args.length == 2) {

                // target entity
                let targetTag;
                // relative entity
                let relativeTag;

                // if a under b estimated shortest path is b above a 
                if (rel == "above") {
                    targetTag = args[0];
                    relativeTag = args[1];
                } else {
                    targetTag = args[1];
                    relativeTag = args[0];
                }

                // stack position of target entity, undefined if arm is holding targetTag
                let targetStackIndex = Interpreter.stackIndex(targetTag, state);
                // stack position of relative entity, undefined if arm is holding targetTag
                let relativeStackIndex = Interpreter.stackIndex(relativeTag, state);

                if (state.holding == relativeTag) {
                    relativeStackIndex = state.arm;
                    if (targetStackIndex == relativeStackIndex) {
                        // move one step
                        result++;
                    }
                    // drop relative
                    result++;
                }
                
                // However, if holding then just move and drop object
                if (state.holding == targetTag) {
                    //
                    // Assumes this object can be drop ontop of underlying object
                    //
                    targetStackIndex = state.arm;
                } else {
                    // estimated cost for picking up targetTag i.e. holding it -> see rel == "holding"
                    let holdingTargetLiteral: Interpreter.Literal = {
                        polarity: true,
                        relation: "holding",
                        args: [targetTag]
                    };
                    result += estimatedPathLength(state, holdingTargetLiteral);
                }
                
                //
                // Now holding 'targetTag'
                //
                
                if (targetStackIndex == relativeStackIndex) {
                    // relative was moved est. one stack when 'holding' target
                    result++;
                } else {
                    // estimated cost for moving targetTag to stack index of relativeTag
                    result += Math.abs(targetStackIndex - relativeStackIndex);
                }
                
                // drop the object
                result++;
            } else {
                console.error("estimatedPathLength() got condition 'above' with args: " + args);
            }
        }
        else if (rel == "ontop") 
        {
            if (args.length == 2) {

                // target entity
                let targetTag = args[0];
                let targetStackIndex = Interpreter.stackIndex(targetTag, state);
                
                // if holding the target object, its stack index is considered the arm position
                if (state.holding == targetTag) {
                    targetStackIndex = state.arm;
                }
                
                // relative entity
                let relativeTag = args[1];
                let relativeStackIndex = Interpreter.stackIndex(relativeTag, state);
                
                // clear the stack from everything above relative
                if (relativeTag == "floor") {
                    // assume that the object will be placed under the shortest stack
                    let stackLengths = state.stacks.map(function(v,i,a){return v.length});
                    relativeStackIndex = argmin(stackLengths, targetStackIndex);
                    let numElsInShortestStack = state.stacks[relativeStackIndex].length;
                    
                    if (numElsInShortestStack > 0) {
                        // need to clear the shortest stack

                        // move the arm to the shortest stack
                        result += Math.abs(relativeStackIndex - state.arm);
                        
                        // 4 moves for each stacked object
                        result += 4 * numElsInShortestStack;
                    }
                } else {
                    if (state.holding != relativeTag) {
                        let holdingRelativeLiteral : Interpreter.Literal = {
                            polarity: true,
                            relation: "holding",
                            args: [relativeTag]
                        };
                        // clearing the way for relative corresponds to holding it, but skipping picking it up
                        result += estimatedPathLength(state, holdingRelativeLiteral) - 1;
                    } else {
                        // drop 'relativeTag'
                        result++;
                    }
                }
                
                //
                // relative should now be accessible
                //
                
                // if not already holding target
                if (state.holding != targetTag) {

                    // estimated path length for picking up 'targetTag'
                    let holdingTargetLiteral : Interpreter.Literal = {
                        polarity: true,
                        relation: "holding",
                        args: [targetTag]
                    };
                    result += estimatedPathLength(state, holdingTargetLiteral);
                }
                
                // move arm to relative stack
                result += Math.abs(relativeStackIndex - targetStackIndex);
                
                // drop the object
                result++;
                
            } else {
                console.error("estimatedPathLength() got condition 'ontop' with args: " + args);
            }
        } else if (rel == "leftof" || rel == "rightof") 
        {
            if (args.length == 2) {
                // target entity
                let targetTag = args[0];
                let targetStackIndex = Interpreter.stackIndex(targetTag, state);
                let targetStackIndexOf = Interpreter.stackIndexOf(targetTag, state);

                // relative entity
                let relativeTag = args[1];
                let relativeStackIndex = Interpreter.stackIndex(relativeTag, state);

                let oppositeRelation;
                if (rel == "leftof") {
                    oppositeRelation = "rightof";
                } else {
                    oppositeRelation = "leftof";
                }

                if (state.holding == relativeTag) {
                    relativeStackIndex = state.arm;
                    let holdingTargetLiteral : Interpreter.Literal = {
                        polarity: true,
                        relation: oppositeRelation,
                        args: [relativeTag,targetTag]
                    };
                    return estimatedPathLength(state, holdingTargetLiteral);
                }

                if (
                     (rel == "leftof" && relativeStackIndex == 0)
                     || (rel == "rightof" && relativeStackIndex == (state.stacks.length - 1))
                   ) {
                    // the relative is in the left/right most stack, need to move it
                    let holdingRelativeLiteral : Interpreter.Literal = {
                        polarity: true,
                        relation: "holding",
                        args: [relativeTag]
                    };
                    result += estimatedPathLength(state, holdingRelativeLiteral);
                    
                    // now holding relative
                    
                    // move one step
                    result++;
                    
                    // drop the relative
                    result++;
                }
                
                if (state.holding == targetTag) {
                    targetStackIndex = state.arm;
                } else {
                // estimated path length for picking up 'targetTag'
                    let holdingTargetLiteral : Interpreter.Literal = {
                        polarity: true,
                        relation: "holding",
                        args: [targetTag]
                    };
                    result += estimatedPathLength(state, holdingTargetLiteral);
                }

                // move arm to target stack
                result += Math.abs(relativeStackIndex - targetStackIndex);
                
                //to go to neighbour stack
                result++;

                // drop the object
                result++;
                
            } else {
                console.error("estimatedPathLength() got condition 'leftof' with args: " + args);
            }
        } else if (rel == "beside") 
        {
            if (args.length == 2) {

                // target entity
                let targetTag = args[0];
                let targetStackIndex = Interpreter.stackIndex(targetTag, state);
                
                let relativeTag = args[1];
                let relativeStackIndex = Interpreter.stackIndex(relativeTag, state);
                
                if (state.holding == relativeTag) {
                    let besideTargetLiteral : Interpreter.Literal = {
                        polarity: true,
                        relation: "beside",
                        args: [relativeTag,targetTag]
                    };
                    return estimatedPathLength(state, besideTargetLiteral);
                }

                if (state.holding == targetTag) {
                    targetStackIndex = state.arm;
                } else {
                    // estimated path length for picking up 'targetTag'
                    let holdingTargetLiteral : Interpreter.Literal = {
                        polarity: true,
                        relation: "holding",
                        args: [targetTag]
                    };
                    result += estimatedPathLength(state, holdingTargetLiteral);
                }
                
                // now holding 'target'

                // move arm to relative stack and prefere the neigbour which is closer to target
                if (relativeStackIndex != state.arm) {
                    result += Math.abs(relativeStackIndex - state.arm) - 1;
                } else {
                    // move target one step away from relative
                    result++;
                }

                // drop the object
                result++;
                
            } else {
                console.error("estimatedPathLength() got condition 'beside' with args: " + args);
            }
        }
        else 
        {
            console.error("estimatedPathLength() got state with relation: " + rel);
        }
        return result;
    }

    class StateGraph implements Graph<WorldState> {

        outgoingEdges(state: WorldState): Edge<WorldState>[] {

            // return value
            let outgoingEdges: Edge<WorldState>[] = [];

            // get states reachable from 'state'
            let outgoingNodes: WorldState[] = getReachableStates(state);

            // prepare the list of edges
            for (let i = 0; i < outgoingNodes.length; i++) {
                outgoingEdges.push({
                    from: state,
                    to: outgoingNodes[i],
                    cost: 1
                });
            }

            return outgoingEdges;
        }

        compareNodes(a: WorldState, b: WorldState): number {
            if (JSON.stringify(a) != JSON.stringify(b)) {
                return 1;
            } else {
                return 0;
            }
        }
    }

    /**
     * generate a list of states reachable in one move
     */
    function getReachableStates(state: WorldState): WorldState[] {

        // return value
        let reachableStates: WorldState[] = [];

        // move left
        if (state.arm > 0) {

            // clone current state
            let leftState = cloneObject(state);

            leftState.arm = state.arm - 1;

            // save reachable state
            reachableStates.push(leftState);
        }

        // move right
        if (state.arm < state.stacks.length - 1) {

            // clone current state
            let rightState = cloneObject(state);

            rightState.arm = state.arm + 1;

            // save reachable state
            reachableStates.push(rightState);
        }

        // pick up / drop object
        let heldObjectTag : string = state.holding;
        let stateArmPos : number = state.arm;
        let stateStackBelowArm : Stack = state.stacks[stateArmPos];
        let numElsInStack : number = stateStackBelowArm.length;
        if (heldObjectTag == null) { // pick up
            if (numElsInStack > 0) {

                // clone current state
                let pickUpState = cloneObject(state);

                // pick up object
                let pickedObject = pickUpState.stacks[stateArmPos].pop();
                pickUpState.holding = pickedObject;

                // save reachable state
                reachableStates.push(pickUpState);
            }
        } else { // drop
            
            // potential object to drop onto
            let stackTopObjectTag : string;
            if (numElsInStack == 0) {
                stackTopObjectTag = "floor";
            } else {
                stackTopObjectTag = stateStackBelowArm[numElsInStack - 1];
            }
            
            let canDrop : boolean = Interpreter.checkRelation("ontop",[heldObjectTag,stackTopObjectTag],state);
            if (canDrop) {

                // clone current state
                let dropState = cloneObject(state);

                // drop object
                dropState.stacks[stateArmPos].push(heldObjectTag);
                dropState.holding = null;

                // save reachable state
                reachableStates.push(dropState);
            }
        }

        return reachableStates;
    }

    /**
     * used for cloning objects
     * 
     * @param obj the object to clone
     */
    function cloneObject(obj) : typeof obj {
        if (obj === null || typeof obj !== 'object') {
            return obj;
        }
        var temp : typeof obj = obj.constructor();
        for (var key in obj) {
            temp[key] = cloneObject(obj[key]);
        }
        return temp;
    }
    
    /**
     * mathematical min over the number in 'vs'
     * 
     * @param vs the number through which to search
     */
    export function min(vs : number[]) : number {
        
        // return value
        let min : number = Infinity;
        
        for (let i = 0; i < vs.length; i++) {
            if (vs[i] < min) {
                min = vs[i];
            }
        }
        
        return min;
    }
    
    /**
     * mathematical argmin over the number in 'vs'
     * 
     * @param vs the number through which to search
     * @param startPos the place in the list from which to initiate circular search
     */
    export function argmin(vs : number[], startPos? : number) : number {
        
        // return value
        let argmin : number;
        
        // minimum so far
        let min = Infinity;
        
        if (typeof startPos == "undefined") {
            startPos = 0;
        }
        
        let ns : collections.Queue<number> = new collections.Queue<number>();
        ns.enqueue(startPos)
        while (ns.size() > 0) {
            let i = ns.dequeue();
            if (vs[i] < min) {
                argmin = i;
                min = vs[i];
            }
            if (i >= startPos && i+1 < vs.length) {
                ns.enqueue(i+1);
            }
            if (i <= startPos && i-1 >= 0) {
                ns.enqueue(i-1);
            }
        }
        
        return argmin;
    }

}