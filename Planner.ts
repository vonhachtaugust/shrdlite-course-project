///<reference path="World.ts"/>
///<reference path="Interpreter.ts"/>
///<reference path="Graph.ts"/>

/** 
* Planner module
*
* The goal of the Planner module is to take the interpetation(s)
* produced by the Interpreter module and to plan a sequence of actions
* for the robot to put the world into a state compatible with the
* user's command, i.e. to achieve what the user wanted.
*
* The planner should use your A* search implementation to find a plan.
*/
module Planner {

    //////////////////////////////////////////////////////////////////////
    // exported functions, classes and interfaces/types

    /**
     * Top-level driver for the Planner. Calls `planInterpretation` for each given interpretation generated by the Interpreter. 
     * @param interpretations List of possible interpretations.
     * @param currentState The current state of the world.
     * @returns Augments Interpreter.InterpretationResult with a plan represented by a list of strings.
     */
    export function plan(interpretations: Interpreter.InterpretationResult[], currentState: WorldState): PlannerResult[] {
        var errors: Error[] = [];
        var plans: PlannerResult[] = [];
        interpretations.forEach((interpretation) => {
            try {
                var result: PlannerResult = <PlannerResult>interpretation;
                result.plan = planInterpretation(result.interpretation, currentState);
                if (result.plan.length == 0) {
                    result.plan.push("That is already true!");
                }
                plans.push(result);
            } catch (err) {
                errors.push(err);
            }
        });
        if (plans.length) {
            return plans;
        } else {
            // only throw the first error found
            throw errors[0];
        }
    }

    export interface PlannerResult extends Interpreter.InterpretationResult {
        plan: string[];
    }

    export function stringify(result: PlannerResult): string {
        return result.plan.join(", ");
    }

    //////////////////////////////////////////////////////////////////////
    // private functions

    /**
     * The core planner function. The code here is just a template;
     * you should rewrite this function entirely. In this template,
     * the code produces a dummy plan which is not connected to the
     * argument `interpretation`, but your version of the function
     * should be such that the resulting plan depends on
     * `interpretation`.
     *
     * 
     * @param interpretation The logical interpretation of the user's desired goal. The plan needs to be such that by executing it, the world is put into a state that satisfies this goal.
     * @param state The current world state.
     * @returns Basically, a plan is a
     * stack of strings, which are either system utterances that
     * explain what the robot is doing (e.g. "Moving left") or actual
     * actions for the robot to perform, encoded as "l", "r", "p", or
     * "d". The code shows how to build a plan. Each step of the plan can
     * be added using the `push` method.
     */
    function planInterpretation(interpretation: Interpreter.DNFFormula, state: WorldState): string[] {

        var isGoal = (n: any) => goal(interpretation, n);

        // This function returns a dummy plan involving a random stack

        // development debug prints
        console.log(interpretation);
        console.log("=================================================");

        console.log("current state:");
        console.log(state);
        console.log();
        console.log("reachable states:")
        console.log(getReachableStates(state));
        console.log()

        console.log("=================================================");

        let stateGraph: StateGraph = new StateGraph();

        console.log("=================================================");

        console.log("A star search");
        console.log();
        
        var heuristic = (n: any) => heuristicFunction(n, interpretation);
        
        let path = aStarSearch(
            stateGraph,
            state,
            isGoal,
            heuristic,
            10
        );
        
        console.log()
        console.log("aStarSearch output path:");
        console.log(path);
        console.log()
        
        console.log("=================================================");

        // below is the dummy plan generation
        do {
            var pickstack = Math.floor(Math.random() * state.stacks.length);
        } while (state.stacks[pickstack].length == 0);
        var plan: string[] = [];

        // First move the arm to the leftmost nonempty stack
        if (pickstack < state.arm) {
            plan.push("Moving left");
            for (var i = state.arm; i > pickstack; i--) {
                plan.push("l");
            }
        } else if (pickstack > state.arm) {
            plan.push("Moving right");
            for (var i = state.arm; i < pickstack; i++) {
                plan.push("r");
            }
        }

        // Then pick up the object2
        var obj = state.stacks[pickstack][state.stacks[pickstack].length - 1];
        plan.push("Picking up the " + state.objects[obj].form,
            "p");

        if (pickstack < state.stacks.length - 1) {
            // Then move to the rightmost stack
            plan.push("Moving as far right as possible");
            for (var i = pickstack; i < state.stacks.length - 1; i++) {
                plan.push("r");
            }

            // Then move back
            plan.push("Moving back");
            for (var i = state.stacks.length - 1; i > pickstack; i--) {
                plan.push("l");
            }
        }

        // Finally put it down again
        plan.push("Dropping the " + state.objects[obj].form,
            "d");

        return plan;
    }

    /**
     * function used by isGoal to check the current world state with the interpretation
     */
    function goal(interpretation: Interpreter.DNFFormula, state: WorldState): boolean {
        // for each found interpretation
        for (let i = 0; i < interpretation.length; i++) {
            // for each disjunctive goal
            for (let j = 0; j < interpretation[i].length; j++) {
                let rel: string = interpretation[i][j].relation;
                let args: string[] = interpretation[i][j].args;
                // fufill a conjunctive goal
                if (Interpreter.checkRelation(rel, args, state) && conjunctive(rel, args, interpretation[i][j], state)) {
                    return true;
                }
            }
        }
        return false;
    }

    function conjunctive(relation: string, args: string[], interpretation: any, state : WorldState): boolean {
        // function assumes  previous required conditions between number of arguments given a relation etc. are handled. See Interpreter.ts

        // for each conjunctive goal
        for (let i = 0; i < interpretation.length; i++) {
            if (relation == "holding") {
                return (state.holding == interpretation.args[0]);
             }
            else if ((relation == "inside") || (relation == "ontop")) {
                if (Interpreter.isInSameStack(interpretation.args[0], interpretation.args[1], state)) {
                    return (Interpreter.stackIndexOf(interpretation.args[0],state) + 1 == Interpreter.stackIndexOf(interpretation.args[1],state));
                }
                return false;
            }
            else if (relation ==  "above") {
                if (Interpreter.isInSameStack (interpretation.args[0], interpretation.args[1], state)) {
                    return (Interpreter.stackIndexOf(interpretation.args[0],state) > Interpreter.stackIndexOf(interpretation.args[1],state));       
                }
                return false;
            }
            else if (relation == "under") {
                if (Interpreter.isInSameStack(interpretation.args[0], interpretation.args[1], state)) {
                    return (Interpreter.stackIndexOf(interpretation.args[0],state) < Interpreter.stackIndexOf(interpretation.args[1],state));
                }
                return false;
            }        else if (relation == "beside") {
                return (Interpreter.stackIndex(interpretation.args[0], state) + 1 == Interpreter.stackIndex(interpretation.args[1], state))
                    || (Interpreter.stackIndex(interpretation.args[0], state) - 1 == Interpreter.stackIndex(interpretation.args[1], state));
            }
            else if (relation == "leftof") {
                return (Interpreter.stackIndex(interpretation.args[0], state) - 1 == Interpreter.stackIndex(interpretation.args[1], state));
            }
            else if (relation == "rightof") {
                return (Interpreter.stackIndex(interpretation.args[0], state) + 1 == Interpreter.stackIndex(interpretation.args[1], state));
            }     
        }
        // the relation doesn't exist.
        return false;
    }


    /**
     * function for calculating the heuristic for state 's'
     */
    function heuristicFunction(state: WorldState, interpretation : Interpreter.DNFFormula) : number {
        
        let disjGoals : Interpreter.Literal[][] = interpretation;
        
        // result heuristic will be the minimum of the heuristics for the disjunctions
        let minHeuristic = Infinity;
        
        // assumes that interpretation is a list of disjunctive goals
        for (let i = 0; i < disjGoals.length; i++) {
            
            // list of conjunctions for this disjunctive goal
            let thisDisjunction : Interpreter.Literal[] = disjGoals[i];
            
            // heuristic for this disjunction will be the sum of the heuristics for the conjunctions
            let thisHeuristic = 0;
            
            for (let j = 0; j < thisDisjunction.length; j++) {
                let thisConjunction : Interpreter.Literal = thisDisjunction[j];
                thisHeuristic += estimatedPathLength(state,thisConjunction)
            }
            
            if (thisHeuristic < minHeuristic) {
                minHeuristic = thisHeuristic;
            }
        }
        
        return minHeuristic;
    }
    
    function estimatedPathLength(state : WorldState, condition : Interpreter.Literal) : number {
        
        // return value
        let result : number = 0;
        
        //let polarity = condition.polarity; // assumed to be true for now
        let rel = condition.relation;
        let args = condition.args;
        
        if (rel == "inside") {
            rel = "ontop";
        }
        
        if (rel == "holding") {
            if (args.length == 1) {
                
                let targetTag = args[0];
                let targetStackIndex = Interpreter.stackIndex(targetTag, state);
                let targetStackIndexOf = Interpreter.stackIndexOf(targetTag, state);
                
                // move arm to right stack
                result += Math.abs(state.arm - targetStackIndex);
                
                // number of obstacles in the of picking up 'target'
                let numObstacles = state.stacks[targetStackIndex].length - (targetStackIndexOf + 1);
                
                // for each obstacle, pick up (+1), move away (+1), drop (+1) and move back (+1), (+4) in total
                result += 4 * numObstacles;
                
                // pick up 'target'
                result++;
    
            } else {
               console.error("estimatedPathLengt h() got conditi on 'holding' with a rgs: " + args)
            }
        } else if (rel == "ontop") {
            if (args.length == 2) {
                
                // target entity
                let targetTag = args[0];
                let targetStackIndex = Interpreter.stackIndex(targetTag, state);
                
                // relative entity
                let relativeTag = args[1];
                let relativeStackIndex = Interpreter.stackIndex(relativeTag, state);
                
                // clearing the way for relative corresponds to holding it, but skipping picking it up
                if (relativeTag != "floor") {
                    let holdingRelativeLiteral : Interpreter.Literal = {
                        polarity: true,
                        relation: "holding",
                        args: [relativeTag]
                    };
                    result += estimatedPathLength(state, holdingRelativeLiteral) - 1;
                }
                
                // heuristic for picking up 'targetTag'
                let holdingTargetLiteral : Interpreter.Literal = {
                    polarity: true,
                    relation: "holding",
                    args: [targetTag]
                };
                result += estimatedPathLength(state, holdingTargetLiteral);
                
                // move arm to target stack
                result += Math.abs(relativeStackIndex - targetStackIndex);
                
                // drop object
                result++;
                
            } else {
                console.error("estimatedPathLength() got condition 'holding' with args: " + args)
            }
        } else {
            console.error("estimatedPathLength() got state with relation: " + rel);
        }
        
        return result;
    }

    class StateGraph implements Graph<WorldState> {

        outgoingEdges(state: WorldState): Edge<WorldState>[] {

            // return value
            let outgoingEdges: Edge<WorldState>[] = [];

            // get states reachable from 'state'
            let outgoingNodes: WorldState[] = getReachableStates(state);

            // prepare the list of edges
            for (let i = 0; i < outgoingNodes.length; i++) {
                outgoingEdges.push({
                    from: state,
                    to: outgoingNodes[i],
                    cost: 1
                });
            }

            return outgoingEdges;
        }

        compareNodes(a: WorldState, b: WorldState): number {
            if (JSON.stringify(a) != JSON.stringify(b)) {
                return 1;
            } else {
                return 0;
            }
        }
    }

    /**
     * generate a list of states reachable in one move
     */
    function getReachableStates(state: WorldState): WorldState[] {

        // return value
        let reachableStates: WorldState[] = [];

        // move left
        if (state.arm > 0) {

            // clone current state
            let leftState = cloneObject(state);

            leftState.arm = state.arm - 1;

            // save reachable state
            reachableStates.push(leftState);
        }

        // move right
        if (state.arm < state.stacks.length - 1) {

            // clone current state
            let rightState = cloneObject(state);

            rightState.arm = state.arm + 1;

            // save reachable state
            reachableStates.push(rightState);
        }

        // pick up / drop object
        let heldObjectTag : string = state.holding;
        let stateArmPos : number = state.arm;
        let stateStackBelowArm : Stack = state.stacks[stateArmPos];
        let numElsInStack : number = stateStackBelowArm.length;
        if (heldObjectTag == null) { // pick up
            if (numElsInStack > 0) {

                // clone current state
                let pickUpState = cloneObject(state);

                // pick up object
                let pickedObject = pickUpState.stacks[stateArmPos].pop();
                pickUpState.holding = pickedObject;

                // save reachable state
                reachableStates.push(pickUpState);
            }
        } else { // drop
            
            // potential object to drop onto
            let stackTopObjectTag : string;
            if (numElsInStack == 0) {
                stackTopObjectTag = "floor";
            } else {
                stackTopObjectTag = stateStackBelowArm[numElsInStack - 1];
            }
            
            let canDrop : boolean = Interpreter.checkRelation("ontop",[heldObjectTag,stackTopObjectTag],state);
            if (canDrop) {

                // clone current state
                let dropState = cloneObject(state);

                // drop object
                dropState.stacks[stateArmPos].push(heldObjectTag);
                dropState.holding = null;

                // save reachable state
                reachableStates.push(dropState);
            }
        }

        return reachableStates;
    }

    /**
     * used for cloning objects
     */
    function cloneObject(obj) {
        if (obj === null || typeof obj !== 'object') {
            return obj;
        }
        var temp = obj.constructor();
        for (var key in obj) {
            temp[key] = cloneObject(obj[key]);
        }
        return temp;
    }

}